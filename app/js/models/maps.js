// Generated by CoffeeScript 1.6.2
define(["jquery", "underscore", "backbone", "async!http://maps.google.com/maps/api/js?sensor=false!callback", "http://google-maps-utility-library-v3.googlecode.com/svn/trunk/markerclusterer/src/markerclusterer.js", "text!html/window.html"], function($, _, Backbone, maps, clusters, tWindow) {
  var view;

  view = Backbone.View.extend({
    el: '#gmap',
    initialize: function(options) {
      var self;

      self = this;
      _.bindAll(this);
      Backbone.Events.on("location", this.go);
      this.geocoder = new google.maps.Geocoder();
      this.markers = [];
      this.windows = [];
      this.latlng = {};
      return this.addresses(options);
    },
    addresses: function(collection) {
      var i, out, _i, _len;

      out = [];
      for (_i = 0, _len = collection.length; _i < _len; _i++) {
        i = collection[_i];
        this.coordinates(i);
      }
      return out;
    },
    /* ASYNC CALL
    */

    coordinates: function(data) {
      var address, self, str;

      self = this;
      data = data.attributes;
      address = data.address[0];
      str = address.street + ', ' + address.city + ', ' + address.state + ' ' + address.country;
      return this.geocoder.geocode({
        'address': str
      }, function(results, status) {
        var key, loc;

        if (status === 'OK') {
          key = data.org.id;
          loc = results[0].geometry.location;
          data.lat = loc.ob;
          data.lng = loc.pb;
          self.markers[key] = self.createMarkers(data);
          self.windows[key] = self.createWindows(data);
          return google.maps.event.addListener(self.markers[key], 'click', function(event) {
            self.map.panTo(event.latLng);
            self.map.setZoom(10);
            return self.windows[key].open(self.map, self.markers[key]);
          });
        } else {
          return console.log("Geocode was not successful for the following reason: " + status);
        }
      });
    },
    render: function() {
      var container;

      this.config = {
        zoom: 4,
        center: new google.maps.LatLng(38, -95),
        mapTypeId: google.maps.MapTypeId.ROADMAP
      };
      container = document.getElementById('gmap');
      if (container !== null) {
        this.map = new google.maps.Map(container, this.config);
      }
      return this.start();
    },
    start: function() {
      var self;

      self = this;
      _.each(this.locations, function(value, key) {
        self.markers[key] = self.createMarkers(value);
        self.windows[key] = self.createWindows(value);
        return google.maps.event.addListener(self.markers[key], 'click', function(event) {
          self.map.panTo(event.latLng);
          self.map.setZoom(10);
          return self.windows[key].open(self.map, self.markers[key]);
        });
      });
      return _.defer(this.clusterize);
    },
    createMarkers: function(data) {
      var point, pos, self, title;

      self = this;
      title = data.org.name;
      pos = new google.maps.LatLng(data.lat, data.lng);
      point = {
        position: pos,
        map: self.map,
        title: title
      };
      return new google.maps.Marker(point);
    },
    createWindows: function(data) {
      var html, self;

      self = this;
      html = _.template(tWindow, {
        address: data.address,
        org: data.org,
        pic: self.pic
      });
      return this.windows[data.org.id] = new google.maps.InfoWindow({
        content: html
      });
    },
    clusterize: function() {
      var error;

      try {
        return this.clusters = new MarkerClusterer(this.map, this.markers);
      } catch (_error) {
        error = _error;
        return console.log(error);
      }
    },
    go: function(location) {
      var g, out, self;

      console.log(location);
      self = this;
      out = {};
      g = new google.maps.Geocoder();
      g.geocode({
        'address': location
      }, function(results, status) {
        var loc;

        if (status === 'OK') {
          loc = results[0].geometry.location;
          self.map.setZoom(6);
          return self.map.panTo(loc);
        } else {
          return console.log("Geocode was not successful for the following reason: " + status);
        }
      });
      return location;
    }
  });
  return view;
});
